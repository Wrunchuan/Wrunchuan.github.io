<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>入门Spring</title>
      <link href="/2021/11/08/%E5%85%A5%E9%97%A8Spring/"/>
      <url>/2021/11/08/%E5%85%A5%E9%97%A8Spring/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Spring"><a href="#1-Spring" class="headerlink" title="1.Spring"></a>1.Spring</h1><h2 id="1-1简介"><a href="#1-1简介" class="headerlink" title="1.1简介"></a>1.1简介</h2><p>给软件带来了春天</p><p>前身interface21.0的前身</p><p>2004年正式发布</p><p>Rod Johnson创始人-学音乐的</p><p>spring理念：使现有的技术更容易使用，本身是一个大杂烩整合了现有的技术框架</p><p>SSH：Struct2+Spring+HIbernate</p><p>SSM：SpringMVC+Spring+Mybatis</p><p>官网:</p><p>官方下载地址：</p><p>Github：</p><!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --><dependency>    <groupId>org.springframework</groupId>    <artifactId>spring-webmvc</artifactId>    <version>5.3.10</version></dependency><p>Spring是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架！！</p><p>Sping是一个开源的免费的框架（容器）！</p><p>Sping是一个轻量级的，非入侵式的框架！</p><p>控制反转，面向切面编程</p><p>支持事物的处理，对框架整合的支持！</p><p>官网</p><p><a href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/overview.html#overview-spring">https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/overview.html#overview-spring</a></p><p>官方下载地址</p><p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html">https://docs.spring.io/spring-framework/docs/current/reference/html/core.html</a></p><p>导包</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="1-2优点"><a href="#1-2优点" class="headerlink" title="1.2优点"></a>1.2优点</h2><ul><li><p>spring是一个开源免费的框架（容器）!</p></li><li><p>spring是一个轻量级的。非入侵式的框架！</p></li><li><p>控制反转（IOC），面向切面编程（AOP）</p></li><li><p>支持事物的处理，对框架整合的支持</p><p>总结：Spring就是一个轻量级的控制反转（IOC）和面向切面</p></li></ul><h2 id="1-3组成"><a href="#1-3组成" class="headerlink" title="1.3组成"></a>1.3组成</h2><h2 id="1-4扩展"><a href="#1-4扩展" class="headerlink" title="1.4扩展"></a>1.4扩展</h2><ul><li><p>spring boot</p><ul><li>一个快速开发的脚手架</li><li>基于SpringBoot可以快速的开发单个微服务</li><li>约定大于配置</li></ul></li><li><p>Spring Cloud</p></li><li><p>SpringCLoud是基于SpringBoot实现的</p><p>因为现在大多数公司都在使用springboot进行快速开发，学习springboot的前提，需要完全掌握spring和springMVC！承上启下的作用！</p><p>弊端：发展太久之后，违背了原来的理念！配置十分繁琐！</p></li></ul><h2 id="2-IOC理论推导"><a href="#2-IOC理论推导" class="headerlink" title="2.IOC理论推导"></a>2.IOC理论推导</h2><ol><li><p>UserDao接口</p></li><li><p>UserDaoImpl实现类</p></li><li><p>UserService业务接口</p></li><li><p>UserServiceImpl业务实现类</p></li></ol><p>在我们之前的业务中，用户的需求可能会影响我们原来的代码我们需要根据用户的需求来修改原代码，如果代码十分大，修改一次的成本代价十分昂贵</p><p>我们使用一个Set接口实现，已经发生了革命性的变化</p><ul><li>之前，程序是主动创建对象，控制权在程序员手上</li><li>使用了set注入后，程序不再具有主动性，而是变成了被动的接受对象</li></ul><p>这种思想本质上解决了问题，我们程序员不用再去管理对象的创建。系统的耦合性大大降低，可以更加专注的在业务的实现这是IOC的原型1</p><p>在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改代码！</p><p>我们使用一个set接口实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前，程序是主动创建对象！控制权在程序员手上！</p><p>使用了set注入后，程序不再具有主动性，而是变成客观性</p><p>IOC创建对象的方式</p><p>1使用无参对象创建对象，默认！</p><p>2假设使用有参创建对象，</p><p>​      1.下标赋值</p><p>​      2.类型</p><p>​      3.参数名</p><p>总结在配置文件的时候，容器中管理的对象已经初始化了！</p><h1 id="2-IOC"><a href="#2-IOC" class="headerlink" title="2.IOC"></a>2.IOC</h1><h2 id="IOC的本质"><a href="#IOC的本质" class="headerlink" title="IOC的本质"></a>IOC的本质</h2><p><strong>控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法</strong>，没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方。</p><p>控制反转：可以理解为控制 <strong>对象创建</strong> 的 主动权 反转了。原来对象创建要由我们编写的程序控制，主动权在程序手里，控制反转后就将创建对象的主动权移交给第三方，这样可以降低程序代码间的耦合性，减少了修改代码的工作量。</p><h1 id="3-HelloSpring"><a href="#3-HelloSpring" class="headerlink" title="3.HelloSpring"></a>3.HelloSpring</h1><h1 id="4-IOC创建对象"><a href="#4-IOC创建对象" class="headerlink" title="4.IOC创建对象"></a>4.IOC创建对象</h1><p>1.使用无参构造创建对象</p><p>2.假设我们要使用有参构造创建对象</p><ol><li><p>下标赋值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--第一种下标赋值--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;王润川&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>类型</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--     不建议使用，只通过类型创建       &lt;constructor-arg type=&quot;String&quot; value=&quot;wangrun&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            d参数名来创建对象--&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>直接通过参数命名</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;swr&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>总结：在配置文件加载的时候，容器中管理的对象已经初始化了</p><h1 id="5-spring配置"><a href="#5-spring配置" class="headerlink" title="5.spring配置"></a>5.spring配置</h1><h3 id="5-1别名"><a href="#5-1别名" class="headerlink" title="5.1别名"></a>5.1别名</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;dlksafjlsa&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-2、bean的配置"><a href="#5-2、bean的配置" class="headerlink" title="5.2、bean的配置"></a>5.2、bean的配置</h3><h2 id="5-3、import导入"><a href="#5-3、import导入" class="headerlink" title="5.3、import导入"></a>5.3、import导入</h2><p>​    这个import，一般用于团队开发使用，他可以将多个配置文件，导入合并为一个</p><p>​    假设，现在项目中有多个人开发</p><p>​    这三个人负责不同的类开发，不同的类需要注册在不同的bean中，我们可以利用import将所有人的beans.xml合并成一个总的！</p><p>​    使用的适合，直接使用总的就行了</p><h1 id="6-依赖注入"><a href="#6-依赖注入" class="headerlink" title="6.依赖注入"></a>6.依赖注入</h1><h2 id="6-1构造注入"><a href="#6-1构造注入" class="headerlink" title="6.1构造注入"></a>6.1构造注入</h2><h2 id="6-2set方式注入（重点）"><a href="#6-2set方式注入（重点）" class="headerlink" title="6.2set方式注入（重点）"></a>6.2set方式注入（重点）</h2><p>依赖注入！set注入</p><p>依赖：bean对象的 创建依赖于容器</p><p>注入：bean对象中的所有属性，由容器来注入</p><p>环境搭建</p><h3 id="1-复杂类型"><a href="#1-复杂类型" class="headerlink" title="1.复杂类型"></a>1.复杂类型</h3><h3 id="2-真实测试对象"><a href="#2-真实测试对象" class="headerlink" title="2.真实测试对象"></a>2.真实测试对象</h3><h2 id="6-3拓展方式"><a href="#6-3拓展方式" class="headerlink" title="6.3拓展方式"></a>6.3拓展方式</h2><p>我们可以使用p命名空间和c命名空间</p><p>注意点：p命名和c命名不能直接使用，需要导入xml约束</p><p>byName：会自动在容器上下文中查找，和自己对象set方法后面的值对应的bean id！</p><p>byType：会自动在容器上下文中查找，和自己对象属性类型相同的bean！</p><p>@Resource和@Autowired的区别：</p><p>都是用来自动装配的，都可以放在属性字段上</p><p>@Autowired通过bytype 的方式实现，而且必须要求这个对象存在！</p><p>@Resource默认通过byName的方式实现，如果找不到名字，则通过byType实现！如果两个都找不到的情况下，就报错！</p><p>执行顺序不同：@Autowired通过bytype的方式实现，@Resource默认通过byname的方式实现。</p><h1 id="8-使用注解开发"><a href="#8-使用注解开发" class="headerlink" title="8.使用注解开发"></a>8.使用注解开发</h1><p>在spring4之后，要使用注解开发，必须要保证aop的包导入了</p><h2 id="1-bean"><a href="#1-bean" class="headerlink" title="1.bean"></a>1.bean</h2><h2 id="2-属性如何注入"><a href="#2-属性如何注入" class="headerlink" title="2.属性如何注入"></a>2.属性如何注入</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">//相当于&lt;property name=&quot;name&quot; value=&quot;kuangshen&quot;/&gt;</span></span><br><span class="line">    <span class="meta">@Value(&quot;wangrc&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-衍生的注解"><a href="#3-衍生的注解" class="headerlink" title="3.衍生的注解"></a>3.衍生的注解</h2><p>@Component有几个衍生注解，我们在web开发中，会按照mvc三层构架分层。</p><p>dao【@Repository】</p><p>service【@Service】</p><p>controller【@Controller】</p><p>这四个注解功能都是一样的，都是代表将某个类注册到Spring中，装配Bean中</p><h2 id="4-自动装配置"><a href="#4-自动装配置" class="headerlink" title="4.自动装配置"></a>4.自动装配置</h2><p>@Autowired:自动装配通过类型。名字 如果Autowired不能唯一自动装配上属性，则需要通过@Qualifier（value=”xxx”）</p><p>@Nullable 字段标记了这个注解，说明这个字段可以为null @Resource 自动装通过名字，类型 </p><h2 id="5-作用域"><a href="#5-作用域" class="headerlink" title="5.作用域"></a>5.作用域</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">//相当于&lt;property name=&quot;name&quot; value=&quot;kuangshen&quot;/&gt;</span></span><br><span class="line">    <span class="meta">@Value(&quot;wangrc&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h2><p>xml与注解：</p><p>xml更加万能，适用于任何场合！维护简单方便</p><p>注解不是直接类适用不了，维护相对复杂！</p><p>xml与注解最佳实践</p><p>xml用来管理bean；</p><p>注解只负责完成属性的注入；</p><p>我们在适用的过程中，只需要一个问题，必须让注解生效，就需要开启注解的支持</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">&quot;com.kuang&quot;</span>/&gt;    &lt;context:annotation-config/&gt;&lt;context:annotation-config/&gt;</span><br></pre></td></tr></table></figure><h1 id="9-使用java的方式配置Spring"><a href="#9-使用java的方式配置Spring" class="headerlink" title="9.使用java的方式配置Spring"></a>9.使用java的方式配置Spring</h1><p>我们现在要完全不使用Spring的xml配置了，全权交给java来做！</p><p>javaConfig是Spring的一个子项目！</p><h1 id="10-AOP代理模式"><a href="#10-AOP代理模式" class="headerlink" title="10.AOP代理模式"></a>10.AOP代理模式</h1><p>为什么要学代理模式？因为这就是springAOP的底层！【springAOP和springMVC】</p><p>代理模式的分类</p><ul><li><p>静态代理</p></li><li><p>动态代理</p></li></ul><h2 id="10-1"><a href="#10-1" class="headerlink" title="10.1"></a>10.1</h2><p>角色分析：</p><p>​    抽象角色：一般会使用接口和抽象类来实现</p><p>​     真实角色:被代理的角色</p><p>​      代理角色：代理真实角色，代理真实角色后，我们一般后做些附属操作</p><p>客户：访问代理对象的人！</p><p>代码步骤：</p><p>​    1.接口</p><p>​     2.真实角色</p><p>​       3.代理角色</p><p>​         4.客户端访问代理角色</p><p>代理模式的好处：</p><p>​    可以使真实角色的操作更加纯粹，不用去关注一些公共业务</p><p>​     公共也就交给代理角色！实现了业务的分工</p><p>​      公共业务发生扩展的时候，方便集中管理！</p><p>缺点：</p><p>​     一个真实角色就会产生一个代理角色，代码效率会降低</p><h2 id="10-2"><a href="#10-2" class="headerlink" title="10.2"></a>10.2</h2><h2 id="10-3动态代理"><a href="#10-3动态代理" class="headerlink" title="10.3动态代理"></a>10.3动态代理</h2><ul><li><p> 动态代理和静态代理角色一样</p></li><li><p> 动态代理的代理类是动态生成的，不是我们直接写好的</p></li><li><p> 动态代理分为两大类：基于接口的动态代理，基于类的动态代理</p></li></ul><p>基于接口–JDK动态代理</p><p>基于类：cglib</p><p>java字节码实现：javasisit</p><p>需要了解两个类：proxy，InvocationHandler：调用处理程序</p><p>InvocationHandler</p><p>动态代理的好处：</p><ul><li><p>可以使真实角色的操作更加纯粹，不用去关注一些公共业务</p></li><li><p>公共也就交给代理角色！实现了业务的分工</p></li><li><p>公共业务发生扩展的时候，方便集中管理！</p></li></ul><p>一个动态代理类代理的是一个接口，一般就是对应的一类业务</p><p>一个动态代理类可以代理多个类，只要是实现了同一个接口即可</p><h1 id="11-AOP"><a href="#11-AOP" class="headerlink" title="11.AOP"></a>11.AOP</h1><h2 id="11-1什么是AOP"><a href="#11-1什么是AOP" class="headerlink" title="11.1什么是AOP"></a>11.1什么是AOP</h2><p>方式一：使用spring的API接口【主要是SpringAPI接口实现】</p><p>方式二：自定义来实现AOP【主要是切面定义】</p><p>方式三：使用注解实现</p><h1 id="12-整合Mybatis"><a href="#12-整合Mybatis" class="headerlink" title="12.整合Mybatis"></a>12.整合Mybatis</h1><p>步骤1.导入相关jar包</p><ul><li><p>junit</p></li><li><p>mybatis</p></li><li><p>mysql</p></li><li><p>spring相关的</p></li><li><p>aop织入</p></li><li><p>mybatis-spring【new】</p><p>2.编写配置文件</p><p>3.测试</p><h2 id="12-1回忆mybatis"><a href="#12-1回忆mybatis" class="headerlink" title="12.1回忆mybatis"></a>12.1回忆mybatis</h2><p>1.编写实体类</p><p>2.编写核心配置文件</p><p>3.编写接口</p><p>4.编写Mapper.xml</p><p>5.测试vb </p></li></ul>]]></content>
      
      
      <categories>
          
          <category> CodeStudy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Mybatis </tag>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2021/11/08/Vue%20+%20Element%20UI%20Vue%20%E9%9B%86%E6%88%90%20Element%20UI%20Element%20UI%20%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E4%B8%BB%E8%A6%81%E7%9A%84%E6%A0%87%E7%AD%BE%EF%BC%9A/"/>
      <url>/2021/11/08/Vue%20+%20Element%20UI%20Vue%20%E9%9B%86%E6%88%90%20Element%20UI%20Element%20UI%20%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E4%B8%BB%E8%A6%81%E7%9A%84%E6%A0%87%E7%AD%BE%EF%BC%9A/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue-Element-UI-Vue-集成-Element-UI-Element-UI-后台管理系统主要的标签："><a href="#Vue-Element-UI-Vue-集成-Element-UI-Element-UI-后台管理系统主要的标签：" class="headerlink" title="Vue + Element UI Vue 集成 Element UI Element UI 后台管理系统主要的标签："></a>Vue + Element UI Vue 集成 Element UI Element UI 后台管理系统主要的标签：</h2><p> el-container：构建整个⻚⾯框架。</p><p> el-aside：构建左侧菜单。 </p><p>el-menu：左侧菜单内容，</p><h3 id="常⽤属性："><a href="#常⽤属性：" class="headerlink" title="常⽤属性："></a>常⽤属性：</h3><p> default-openeds：默认展开的菜单，通过菜单的 index 值来关联。</p><p> default-active：默认选中的菜单，通过菜单的 index 值来关联。 </p><p>el-submenu：可展开的菜单，常⽤属性：</p><p> index：菜单的下标，⽂本类型，不能是数值类型。</p><p> template：对应 el-submenu 的菜单名。</p><p> i：设置菜单图标，通过 class 属性实则。</p><p> el-icon-messae </p><p>el-icon-menu </p><p>el-icon-setting </p><p>el-menu-item：菜单的⼦节点，不可再展开，</p><p>常⽤属性： index：菜单的下标，⽂本类型，不能是数值类型。</p><h3 id="Vue-router-来动态构建左侧菜单"><a href="#Vue-router-来动态构建左侧菜单" class="headerlink" title="Vue router 来动态构建左侧菜单"></a>Vue router 来动态构建左侧菜单</h3><p>导航1</p><p>   页面1</p><p>​    页面2</p><p>导航2</p><p>​     页面1   </p><p>​     页面2</p><h3 id="menu与router的绑定"><a href="#menu与router的绑定" class="headerlink" title="menu与router的绑定"></a>menu与router的绑定</h3><p>1.<el-menu>添加啊router属性</el-menu></p><p>2.在页面中添加<router-view>标签它是一个容器，动态渲染你选择的router</router-view></p><p>3.<el-menu-item>标签index值就是要跳转router。</el-menu-item></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>小白入门Mybatis</title>
      <link href="/2021/10/18/Mybatis/"/>
      <url>/2021/10/18/Mybatis/</url>
      
        <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><h2 id="1-1什么是Mybatis"><a href="#1-1什么是Mybatis" class="headerlink" title="1.1什么是Mybatis"></a>1.1什么是Mybatis</h2><ul><li>MyBatis 是一款优秀的持久层框架</li><li>它支持自定义 SQL、存储过程以及高级映射。</li><li>MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。</li><li>MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</li></ul><h2 id="1-2持久层"><a href="#1-2持久层" class="headerlink" title="1.2持久层"></a>1.2持久层</h2><p>数据持久化</p><ul><li><p>持久化就是讲程序的数据在持久状态和瞬时状态转化的过程</p></li><li><p>内存：断电即失</p></li><li><p>数据库（jdbc),io文件持久化</p><p>为什么需要持久化？</p><ul><li><p>有一些对象，不能让他丢掉</p></li><li><p>内存太贵了</p></li></ul></li></ul><h2 id="1-3持久层"><a href="#1-3持久层" class="headerlink" title="1.3持久层"></a>1.3持久层</h2><p>Dao层，service层，controller层</p><ul><li>完成持久化工作的代码块</li><li>层是界限十分明显的</li></ul><h2 id="为什么需要Mybatis"><a href="#为什么需要Mybatis" class="headerlink" title="为什么需要Mybatis"></a>为什么需要Mybatis</h2><ul><li>方便</li><li>传统的JDBC代码太复杂了。简化。框架。自动化。</li><li>帮助程序员将数据存入数据库中</li><li>不用Mybatis也可以。更容易上手，技术没有高低之分</li></ul><p><strong>更重要一点：使用的人多</strong></p><p>Spring SpringMVC SpringBoot</p><h1 id="2-第一个mybatis程序"><a href="#2-第一个mybatis程序" class="headerlink" title="2.第一个mybatis程序"></a>2.第一个mybatis程序</h1><p>思路：搭建环境–&gt;导入mybatis–&gt;编写代码–&gt;测试</p><h2 id="2-1搭建环境"><a href="#2-1搭建环境" class="headerlink" title="2.1搭建环境"></a>2.1搭建环境</h2><p>1.新建项目</p><p>2.删除src</p><p>3.导入maven依赖</p><h2 id="2-2创建一个模块"><a href="#2-2创建一个模块" class="headerlink" title="2.2创建一个模块"></a>2.2创建一个模块</h2><ul><li>编写mybatis的核心配置文件</li><li>编写mybatis的工具类 </li></ul><h2 id="2-3编写代码"><a href="#2-3编写代码" class="headerlink" title="2.3编写代码"></a>2.3编写代码</h2><ul><li>实体类</li><li>Dao接口</li><li>接口实现类由原来的UserDaolmpl转变成一个Mapper配置文件</li></ul><h2 id="2-4"><a href="#2-4" class="headerlink" title="2.4"></a>2.4</h2><ul><li><p>注意点</p></li><li><p>org.apache.ibatis.binding.BindingException: Type class com.kuang.pojo.User is not known to the MapperRegistry.</p></li><li><p>maven由于他的约定大于配置，我们之后可能遇到我们谢谢的配置文件，无法被导出或者生效的问题，解决方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">  &lt;resources&gt;</span><br><span class="line">    &lt;resource&gt;</span><br><span class="line">      &lt;directory&gt;src/main/resource&lt;/directory&gt;</span><br><span class="line">      &lt;includes&gt;</span><br><span class="line">        &lt;include&gt;**/*.properties&lt;/include&gt;</span><br><span class="line">        &lt;include&gt;**/*.xml&lt;/include&gt;</span><br><span class="line">      &lt;/includes&gt;</span><br><span class="line">      &lt;filtering&gt;false&lt;/filtering&gt;</span><br><span class="line">    &lt;/resource&gt;</span><br><span class="line">    &lt;resource&gt;</span><br><span class="line">      &lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">      &lt;includes&gt;</span><br><span class="line">        &lt;include&gt;**/*.properties&lt;/include&gt;</span><br><span class="line">        &lt;include&gt;**/*.xml&lt;/include&gt;</span><br><span class="line">      &lt;/includes&gt;</span><br><span class="line">      &lt;filtering&gt;false&lt;/filtering&gt;</span><br><span class="line">    &lt;/resource&gt;</span><br><span class="line">  &lt;/resources&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure></li></ul><p>junit测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> @Test</span><br><span class="line">  public void test()&#123;</span><br><span class="line">//    第一步获取sqlsession对象</span><br><span class="line">    SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line">//    方式一：getMapper</span><br><span class="line">    UserDao userDao = sqlSession.getMapper(UserDao.class);</span><br><span class="line">    List&lt;User&gt; userList = userDao.getUserList();</span><br><span class="line">    for (User user:userList)&#123;</span><br><span class="line">      System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">    //关闭sqlsession</span><br><span class="line">    sqlSession.close();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可能会遇到的问题：</p><ol><li>配置文件没有注册</li><li>绑定接口错误</li><li>方法名不对</li><li>返回类型不对</li><li>Maven导出资源问题 </li></ol><h1 id="3-CRUD"><a href="#3-CRUD" class="headerlink" title="3.CRUD"></a>3.CRUD</h1><h2 id="1-namespace"><a href="#1-namespace" class="headerlink" title="1.namespace"></a>1.namespace</h2><p>namespace中的包名要和DAO/Mapper接口包一致</p><h2 id="2、select"><a href="#2、select" class="headerlink" title="2、select"></a>2、select</h2><p>选择，查询语句：</p><ul><li><p>id：就是对应的namespace中的方法名</p></li><li><p>resultType：SQL语句执行的返回值</p></li><li><p>parameterType：参数类型</p><p>1.编写接口</p><p>2.编写对应的mapper中的sql语句</p><p>3.测试</p></li></ul><h2 id="3-insert"><a href="#3-insert" class="headerlink" title="3.insert"></a>3.insert</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;insertuser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt;</span><br><span class="line">  insert into mywood.user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;);</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure><h2 id="4-update"><a href="#4-update" class="headerlink" title="4.update"></a>4.update</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;update id=&quot;updateuser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt;</span><br><span class="line">  update mywood.user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125;  where id=#&#123;id&#125;;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure><h2 id="5-delete"><a href="#5-delete" class="headerlink" title="5.delete"></a>5.delete</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;delete id=&quot;deleteuser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt;</span><br><span class="line">  delete from mywood.user where id=#&#123;id&#125;;</span><br><span class="line">&lt;/delete&gt;</span><br></pre></td></tr></table></figure><p>注意点：</p><p>增删改需要提交事务！</p><h2 id="6-分析错误"><a href="#6-分析错误" class="headerlink" title="6.分析错误"></a>6.分析错误</h2><p>1.标签不要匹配错误</p><p>2.resource绑定mapper路径，需要/来执行</p><p>3.程序配置文件必须标准</p><p>4.空指针异常，没有注册到资源</p><p>5.输出的xml出现乱码问题</p><h2 id="7-万能map"><a href="#7-万能map" class="headerlink" title="7.万能map"></a>7.万能map</h2><p>假设，我们的实体类，或者数据库中的表，字段或者参数过多，我们应当参考使用map</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int updateuser2(Map&lt;String,Object&gt; map);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void updateuser2()&#123;</span><br><span class="line">  SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line">  UserDao mapper = sqlSession.getMapper(UserDao.class);</span><br><span class="line">  Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">  map.put(&quot;userid&quot;,6);</span><br><span class="line">  mapper.updateuser2(map);</span><br><span class="line">  sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;insertuser2&quot; parameterType=&quot;Map&quot;&gt;</span><br><span class="line">  insert into mywood.user (id,name,pwd) values (#&#123;userid&#125;,#&#123;username&#125;,#&#123;userpwd&#125;);</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure><p>Map传递参数，直接在SQL中取出key即可！</p><p>对象传递参数，直接在SQL中去对象的属性即可</p><p>只有一个参数的情况下，可以直接在SQL中取到</p><p>多个参数用map或注解</p><h2 id="8-思考题"><a href="#8-思考题" class="headerlink" title="8.思考题"></a>8.思考题</h2><p>模糊查询怎么写</p><p>1.java代码执行的时候，传递通配符%%</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; userList=mapper.getUserList2(&quot;%李%&quot;);</span><br></pre></td></tr></table></figure><p>2.在SQL拼接中使用通配符！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select *from mywood.user where name LIKE &quot;%&quot;#&#123;name&#125;&quot;%&quot;;</span><br></pre></td></tr></table></figure><h1 id="4-配置解析"><a href="#4-配置解析" class="headerlink" title="4.配置解析"></a>4.配置解析</h1><p>1.核心配置文件</p><p>mybatis-config.xml</p><p>MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。</p><ul><li>configuration（配置）<ul><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#properties">properties（属性）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#settings">settings（设置）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases">typeAliases（类型别名）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers">typeHandlers（类型处理器）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#objectFactory">objectFactory（对象工厂）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#plugins">plugins（插件）</a></li><li>environments（环境配置）<ul><li>environment（环境变量）<ul><li>transactionManager（事务管理器）</li><li>dataSource（数据源）</li></ul></li></ul></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#databaseIdProvider">databaseIdProvider（数据库厂商标识）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#mappers">mappers（映射器）</a></li></ul></li></ul><h2 id="2-环境配置（environments）"><a href="#2-环境配置（environments）" class="headerlink" title="2.环境配置（environments）"></a>2.环境配置（environments）</h2><p>MyBatis 可以配置成适应多种环境</p><p><strong>不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。</strong></p><p>学会使用配置多套运行环境</p><p>Mybatis默认的事物管理器就是JDBC，连接池：POOLED</p><h2 id="3-属性"><a href="#3-属性" class="headerlink" title="3.属性"></a>3.属性</h2><p>我们可以通过properties属性来实现引用配置文件</p><p>这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。</p><p>编写一个配置文件</p><p>db.properties</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver= com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mywood ?useSSL=false&amp;amp;serverTimezone=GMTusername=rootpassword=000000</span><br></pre></td></tr></table></figure><p>在核心配置文件中引入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;db.properties&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;000000&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>可以直接引入外部文件</p></li><li><p>可以在期中增加一些属性配置</p></li><li><p>如果两个文件有同一个字段，优先使用外部配置文件的</p></li></ul><h2 id="4-别名"><a href="#4-别名" class="headerlink" title="4.别名"></a>4.别名</h2><ul><li><p>类型别名可为 Java 类型设置一个缩写名字</p></li><li><p>意在降低冗余的全限定类名书写</p></li><li><p>```xml<br><typeAliases>  <typeAlias type="kuang.pojo.User" alias="User"></typeAlias></typeAliases></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean</span><br><span class="line"></span><br><span class="line">```xml</span><br><span class="line">&lt;typeAliases&gt;  &lt;package name=&quot;com.kuang.pojo&quot;/&gt;&lt;/typeAliases&gt;</span><br></pre></td></tr></table></figure></li></ul><p>扫描实体类的包，它默认别名就位这个类的类名，首字母小写！</p><p>在实体类比较少的时候，使用第一种</p><p>如果实体类十分多，建议使用第二种</p><p>第一种可以DIY别名，第二种则不行，如果非要改，则需要在实体类上增加注解</p><h2 id="5-设置"><a href="#5-设置" class="headerlink" title="5.设置"></a>5.设置</h2><p>这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。</p><h2 id="6-其他配置"><a href="#6-其他配置" class="headerlink" title="6.其他配置"></a>6.其他配置</h2><ul><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers">typeHandlers（类型处理器）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#objectFactory">objectFactory（对象工厂）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#plugins">plugins（插件）</a></li></ul><p>mybatis-generator-core</p><p>mybatis-plus</p><p>通用mapper</p><h2 id="7-映射器（mappers）"><a href="#7-映射器（mappers）" class="headerlink" title="7.映射器（mappers）"></a>7.映射器（mappers）</h2><p>MapperRegistry：注册我们的mapper文件</p><p>方式一：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span>  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/kuang/dao/Usermapper.xml&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>方式二：使用class方式注册</p><mapper class="com.kuang.dao.UserDao"><p>注意点：</p><ul><li>接口和他的mapper配置文件必须同名</li><li>接口和他的mapper配置文件必须在同一个包下</li></ul><p>方式三：使用扫描包进行注入绑定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;package name=&quot;com.kuang.dao&quot;/&gt;</span><br></pre></td></tr></table></figure><h2 id="8-生命周期和作用域"><a href="#8-生命周期和作用域" class="headerlink" title="8.生命周期和作用域"></a>8.生命周期和作用域</h2><p>作用域和生命周期类别是至关重要的，因为错误的使用会导致非常严重的并发问题。</p><p>sqlSessionFactoryBuilder：</p><ul><li>一旦创建了SQLSessionFactory，就不需要他了</li><li>局部变量</li></ul><p>SQLSessionFactory</p><ul><li><p>说白了可以想象为：数据库连接池</p></li><li><p>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。</p></li><li><p>因此 SqlSessionFactory 的最佳作用域是应用作用域。</p></li><li><p>最简单的就是使用单例模式或者静态单例模式。</p></li></ul><p><strong>SQLSession</strong></p><ul><li>连接到连接池的一个请求！</li><li>SqlSession 的实例不是线程安全的，因此是不能被共享的</li><li>用完之后关闭，否则资源占用!</li></ul><p>每一个mapper就代表一个具体的业务</p><h1 id="5-解决属性名和字段名不一致的问题"><a href="#5-解决属性名和字段名不一致的问题" class="headerlink" title="5.解决属性名和字段名不一致的问题"></a>5.解决属性名和字段名不一致的问题</h1><p>数据库中的字段</p><p><img src="/2021/10/18/Mybatis/Users\wrc\AppData\Roaming\Typora\typora-user-images\image-20210414212730960.png" alt="image-20210414212730960"></p><p>新建一个项目，拷贝之前的，测试实体类字段不一致的情况</p><p>测试出现问题</p><p><img src="/2021/10/18/Mybatis/Users\wrc\AppData\Roaming\Typora\typora-user-images\image-20210415164125658.png" alt="image-20210415164125658"></p><p><img src="/2021/10/18/Mybatis/Users\wrc\AppData\Roaming\Typora\typora-user-images\image-20210415164130751.png" alt="image-20210415164130751"></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul><li><p>起别名</p><p>select pwd as pwd</p></li><li><p>resultmap</p><p>结果集映射</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;resultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span>/&gt;</span>  <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>resultMap</code> 元素是 MyBatis 中最重要最强大的元素。</p></li><li><p>ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。</p></li><li><p><code>ResultMap</code> 的优秀之处——你完全可以不用显式地配置它们。</p></li></ul><h1 id="6-日志"><a href="#6-日志" class="headerlink" title="6.日志"></a>6.日志</h1><h2 id="6-1日志工厂"><a href="#6-1日志工厂" class="headerlink" title="6.1日志工厂"></a>6.1日志工厂</h2><p>如果一个数据库操作，出现了异常，我们需要排错。日志就是最好的助手！</p><p>曾经：sout。debug</p><p>现在：日志工厂！</p><ul><li>SLF4J</li><li>LOG4J【掌握】</li><li>LOG4J2</li><li>JDK_LOGGING</li><li>COMMONS_LOGGING</li><li>STDOUT_LOGGING【掌握】</li><li>NO_LOGGING</li></ul><p>在Mybatis中具体使用那一个日志实现，在设置中设定</p><p>STDOUT_LOGGING标准日志输出</p><p>在mybatis中配置我们的日志文件</p><h2 id="6-2-log4j"><a href="#6-2-log4j" class="headerlink" title="6.2 log4j"></a>6.2 log4j</h2><ul><li><p>Log4j是<a href="https://baike.baidu.com/item/Apache/8512995">Apache</a>的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是<a href="https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%8F%B0/2438626">控制台</a>、文件、GUI组件</p></li><li><p>我们也可以控制每一条日志的输出格式</p></li><li><p>通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程</p></li><li><p>这些可以通过一个<a href="https://baike.baidu.com/item/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/286550">配置文件</a>来灵活地进行配置，而不需要修改应用的代码。</p><p>1.先导入log4j的包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.log4j.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码log4j.rootLogger=DEBUG,console,file#控制台输出的相关设置log4j.appender.console = org.apache.log4j.ConsoleAppenderlog4j.appender.console.Target = System.outlog4j.appender.console.Threshold=DEBUGlog4j.appender.console.layout = org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=[%c]-%m%n#文件输出的相关设置log4j.appender.file = org.apache.log4j.RollingFileAppenderlog4j.appender.file.File=./log/kuang.loglog4j.appender.file.MaxFileSize=10mblog4j.appender.file.Threshold=DEBUGlog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n#日志输出级别log4j.logger.org.mybatis=DEBUGlog4j.logger.java.sql=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.ResultSet=DEBUGlog4j.logger.java.sql.PreparedStatement=DEBUG</span></span><br></pre></td></tr></table></figure><p>3.配置log4j为日志的实现</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span><span class="comment">&lt;!--    标准日志的实现--&gt;</span>    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;LOG4J&quot;</span>/&gt;</span>  <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4.log4j的使用，直接测试运行刚才的查询</p></li></ul><p><strong>简单使用</strong></p><p>1.要在使用log4g的类中，导入包import org.apache.log4j.Logger</p><p>2.日志对象，参数为当前类的class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Logger logger = Logger.getLogger(UserDaoTest.class);</span><br></pre></td></tr></table></figure><p>3.日志级别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.info(<span class="string">&quot;info进入了testLog4j&quot;</span>);logger.debug(<span class="string">&quot;debug:进入了testLog4j&quot;</span>);logger.error(<span class="string">&quot;error:进入了testLog4j&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="7-分页"><a href="#7-分页" class="headerlink" title="7.分页"></a>7.分页</h1><p>思考：为什么要分页？</p><ul><li>减少数据的处理量</li><li>使用limit分页</li></ul><p>使用Mybatis实现分页，核心SQL</p><p>​    1.接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserByLimit</span><span class="params">(Map&lt;String,Integer&gt; map)</span></span>;</span><br></pre></td></tr></table></figure><p>​    2.Mapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByLimit&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;resultMap&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span>&gt;</span>  select * from mywood.user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;;<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    3.测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Testpublic</span> <span class="function"><span class="keyword">void</span> <span class="title">getuserByLimit</span><span class="params">()</span></span>&#123;  initLogRecord.initLog();  SqlSession sqlSession = MybatisUtils.getSqlSession();  UserDao mapper = sqlSession.getMapper(UserDao.class);  HashMap&lt;String,Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();  hashMap.put(<span class="string">&quot;startIndex&quot;</span>,<span class="number">0</span> );  hashMap.put(<span class="string">&quot;pageSize&quot;</span>,<span class="number">1</span>);  List&lt;User&gt; userList = mapper.getUserByLimit(hashMap);  <span class="keyword">for</span> (User user: userList       ) &#123;    System.out.println(user);  &#125;  sqlSession.close();&#125;</span><br></pre></td></tr></table></figure><h2 id="7-2RowBounds分页"><a href="#7-2RowBounds分页" class="headerlink" title="7.2RowBounds分页"></a>7.2RowBounds分页</h2><p>不再使用SQL实现分页</p><h2 id="7-3分页插件"><a href="#7-3分页插件" class="headerlink" title="7.3分页插件"></a>7.3分页插件</h2><p>Mybatis分页插件PageHelper</p><p>了解即可，万一要使用，需要知道是啥东西就行。</p><h1 id="8-使用注解开发"><a href="#8-使用注解开发" class="headerlink" title="8.使用注解开发"></a>8.使用注解开发</h1><h2 id="8-1面向接口编程"><a href="#8-1面向接口编程" class="headerlink" title="8.1面向接口编程"></a>8.1面向接口编程</h2><p>根本原因：<strong>解耦！</strong></p><h2 id="8-2使用注解开发"><a href="#8-2使用注解开发" class="headerlink" title="8.2使用注解开发"></a>8.2使用注解开发</h2><p>1.注解在接口上实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from User&quot;)</span>  <span class="function">List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>2.需要再核心配置文件中绑定接口！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span>  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;kuang.dao.UserDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.测试使用</p><p>本质：反射机制实现</p><p>底层：动态代理</p><p><strong>Mybatis详细执行流程！</strong></p><p><img src="/2021/10/18/Mybatis/Users\wrc\AppData\Roaming\Typora\typora-user-images\image-20210925163920724.png" alt="image-20210925163920724"></p><p><img src="/2021/10/18/Mybatis/浏览器下载\未命名文件.png" alt="未命名文件"></p><h2 id="8-3-CRUD"><a href="#8-3-CRUD" class="headerlink" title="8.3 CRUD"></a>8.3 CRUD</h2><p>我们可以在工具类创建的时候实现自动提交事物</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span></span>&#123;  SqlSession sqlSession = sqlSessionFactory.openSession(<span class="keyword">true</span>);  <span class="keyword">return</span> sqlSession;&#125;</span><br></pre></td></tr></table></figure><p>编写接口，增加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from User&quot;)</span>    <span class="function">List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span></span>;<span class="comment">//方法存在多个参数，所有的参数必须加上@Param  @Select(&quot;select * from User where id=#&#123;id&#125;&quot;)  User getUserById(@Param(&quot;id&quot;)int id);  @Insert(&quot;insert into User(id,name,pwd) value(#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;)&quot;)  int insertUser(User user);  @Update(&quot;update user set name=#&#123;name&#125;,pwd=#&#123;password&#125; where id=#&#123;id&#125;&quot;)  int UpdateUser(User user);  @Delete(&quot;delete from user where id=#&#123;uid&#125;&quot;)  int DeleteUser(@Param(&quot;uid&quot;)int id);</span></span><br></pre></td></tr></table></figure><p>测试类</p><p>【注意：我们必须要把接口绑定到我们的核心配置文件中】</p><p>关于@Param()注解</p><ul><li><p>基本类型的参数或者String类型，需要加上</p></li><li><p>引用类型不需要加</p></li><li><p>如果只有一个类型的话，可以忽略</p></li><li><p>我们在Sql中引用的就是我们这里的@Param（）中设定的属性名</p></li></ul><h1 id="9-Lombok"><a href="#9-Lombok" class="headerlink" title="9.Lombok"></a>9.Lombok</h1><ul><li><p>java library</p></li><li><p>plugs</p></li><li><p>build tools</p></li><li><p>with one annotation</p><p>@Getter and @Setter<br>@FieldNameConstants<br>@ToString<br>@EqualsAndHashCode<br>@AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor<br>@Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger, @CustomLog<br>@Data<br>@Builder<br>@SuperBuilder<br>@Singular<br>@Delegate<br>@Value<br>@Accessors<br>@Wither</p></li></ul><p>@Data：无参构造，get，set，tostring，hashcode，equals</p><p>@Tostring</p><p>@AllArgsConstructor @NoArgsConstructor</p><h1 id="10-多对一"><a href="#10-多对一" class="headerlink" title="10.多对一"></a>10.多对一</h1><p>多对一：</p><p>关联</p><p>环境搭建</p><p>1.导入lombok</p><p>2.新建实体类Teacher，Student</p><p>3.建立mapper接口</p><p>4.建立Mapper.XML</p><p>5.在核心配置文件中板顶注册我们的Mapper接口或者文件！【方式很多】</p><p>6.测试查询是否能够成功！</p><h2 id="按照查询嵌套处理"><a href="#按照查询嵌套处理" class="headerlink" title="按照查询嵌套处理"></a><strong>按照查询嵌套处理</strong></h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.kuang.dao.StudentMapper&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudentList&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;StudentTeacher&quot;</span>&gt;</span>    select * from Student  <span class="tag">&lt;/<span class="name">select</span>&gt;</span>  <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;StudentTeacher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Student&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span>/&gt;</span><span class="comment">&lt;!--    复杂的属性，我们需要单独处理 对象：association 集合：collection--&gt;</span>    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Teacher&quot;</span> <span class="attr">select</span>=<span class="string">&quot;getTeacher&quot;</span>/&gt;</span>  <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span>  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacher&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span>    select * from teacher where id = #&#123;id&#125;  <span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>按照结果嵌套处理</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudentList2&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;StudentTeacher2&quot;</span>&gt;</span>  select s.id sid, s.name sname ,t.name tname  from student s ,teacher t  where s.tid=t.id;<span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;StudentTeacher2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Student&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sid&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sname&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tname&quot;</span>/&gt;</span>  <span class="tag">&lt;/<span class="name">association</span>&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>回顾MySQL多对一查询方式：</p><ul><li>子查询</li><li>连表查询</li></ul><h1 id="11-一对多"><a href="#11-一对多" class="headerlink" title="11.一对多"></a>11.一对多</h1><p>比如：一个老师拥有多个学生</p><p>对于老师而言，就是一对多的关系</p><p>1.环境搭建，和刚才一样</p><h2 id="按照结果嵌套查询"><a href="#按照结果嵌套查询" class="headerlink" title="按照结果嵌套查询"></a><strong>按照结果嵌套查询</strong></h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacher&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;TeacherStudent&quot;</span>&gt;</span>      select s.id sid,t.id tid,s.name sname,t.name tname       from teacher t,student s       where s.tid=t.id and t.id=#&#123;tid&#125;;    <span class="tag">&lt;/<span class="name">select</span>&gt;</span>  <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;TeacherStudent&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tname&quot;</span>/&gt;</span>    <span class="comment">&lt;!--    复杂的属性，我们需要单独处理 对象：association 集合：collection--&gt;</span><span class="comment">&lt;!--    javaType指定属性的类型--&gt;</span><span class="comment">&lt;!--    集合中的泛型信息，我们使用ofType获取--&gt;</span>    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;students&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Student&quot;</span>&gt;</span>      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sid&quot;</span>/&gt;</span>      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sname&quot;</span>/&gt;</span>      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;tId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span>/&gt;</span>    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span>  <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="按照查询嵌套查询"><a href="#按照查询嵌套查询" class="headerlink" title="按照查询嵌套查询"></a>按照查询嵌套查询</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacher2&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;TeacherStudent2&quot;</span>&gt;</span>  select * from teacher where id=#&#123;tid&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;TeacherStudent2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;students&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;ArrayList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Student&quot;</span> <span class="attr">select</span>=<span class="string">&quot;getStudentByTeacherId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudentByTeacherId&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Student&quot;</span>&gt;</span>  select * from Student where tid=#&#123;tid&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>1.关联-association  【多对一】</p><p>2.集合-collection 【一对多】</p><p>3.javaType &amp; ofType</p><p>​    1.javaType 用来指定实体类中属性的类型</p><p>​    2.ofType用来指定映射到LIst或者集合中的pojo类型，泛型中的约束类型</p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul><li>保证SQL的可读性，尽量保证通俗易懂</li><li>注意一对多喝多对一中，属性名和字段的问题！</li><li>如果问题不好查错误，可以使用日志，建议使用Log4j</li></ul><h2 id="慢SQL"><a href="#慢SQL" class="headerlink" title="慢SQL"></a>慢SQL</h2><p>​    1s 1000s</p><p>面试高频</p><ul><li>mysql引擎</li><li>innoDB底层原理</li><li>索引</li><li>索引优化！</li></ul><h1 id="12-动态SQL"><a href="#12-动态SQL" class="headerlink" title="12.动态SQL"></a>12.动态SQL</h1><p> 什么是动态SQL：</p><p>根据不同的条件生成不同的SQL语句</p><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `blog`(id <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;博客id&#x27;</span>,title <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;博客标题&#x27;</span>,author <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;博客作者&#x27;</span>,create_time DATETIME <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,views <span class="type">INT</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;浏览量&#x27;</span>)ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br></pre></td></tr></table></figure><p>创建一个基础工程</p><ol><li>导包</li><li>编写配置文件</li><li>编写实体类</li><li>编写实体类对应的Mapper接口和Mapper.xml</li></ol><p>IF</p><p>choose（when,otherwise)</p><h2 id="SQL片段"><a href="#SQL片段" class="headerlink" title="SQL片段"></a>SQL片段</h2><p>有的时候，将一部分功能抽出来，方便复用</p><ol><li>使用SQL标签提取公共部分</li><li>在需要说那个的地方使用include标签引用</li></ol><p>注意事项：</p><ul><li>最好基于单表来定义SQL片段</li><li>不要存在where标签</li></ul><h2 id="Foreach"><a href="#Foreach" class="headerlink" title="Foreach"></a>Foreach</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="keyword">select</span> id<span class="operator">=</span>&quot;queryBlogEach&quot; parameterType<span class="operator">=</span>&quot;map&quot; resultType<span class="operator">=</span>&quot;blog&quot;<span class="operator">&gt;</span>  <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> blog  <span class="operator">&lt;</span><span class="keyword">where</span><span class="operator">&gt;</span>    <span class="operator">&lt;</span>foreach collection<span class="operator">=</span>&quot;ids&quot; item<span class="operator">=</span>&quot;id&quot; <span class="keyword">open</span><span class="operator">=</span>&quot;(&quot; <span class="keyword">close</span><span class="operator">=</span>&quot;)&quot; separator<span class="operator">=</span>&quot;or&quot;<span class="operator">&gt;</span>      id<span class="operator">=</span>#&#123;id&#125;    <span class="operator">&lt;</span><span class="operator">/</span>foreach<span class="operator">&gt;</span>  <span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">where</span><span class="operator">&gt;</span><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">select</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>动态SQL就是在拼接SQL语句，我们只要保证SQL的正确性，按照SQL的格式，去排列组合就可以了！</p><p>建议：</p><ul><li>先在mysql中写出完整的SQL语句，再来进行SQL拼接</li></ul><h1 id="13-缓存"><a href="#13-缓存" class="headerlink" title="13. 缓存"></a>13. 缓存</h1><h2 id="13-1-简介"><a href="#13-1-简介" class="headerlink" title="13.1 简介"></a>13.1 简介</h2><p>查询：链接数据库，耗资源！</p><p>一次查询的结果，给他暂存在一个可以直接取到的地方！–&gt;内存：缓存</p><p>我们再次查询相同数据的时候，直接走缓存，就不用走数据库了</p><p>1.什么是缓存</p><ul><li>存在内存中的临时数据</li><li>解决了高并发的问题</li></ul><ol start="2"><li><p>为什么用缓存：</p><p>减少和数据库的交互次数，减少系统开销，提高系统效率</p></li><li><p>什么样的数据使用缓存：</p><p>经常查询并且不经常改变的数据。【可以使用缓存】</p><h2 id="13-2Mybatis缓存"><a href="#13-2Mybatis缓存" class="headerlink" title="13.2Mybatis缓存"></a>13.2Mybatis缓存</h2><p>mybatis包含一个非常强大的查询缓存特性，它可以非常方便地定制喝喝配置缓存。缓存可以极大的提升查询效率。</p><p>mybatis系统中默认定义了两级缓存：一级缓存和二级缓存</p><ul><li><p>默认情况下，只有一级缓存开启。（SQLSession级别的缓存，也称为本地缓存）</p></li><li><p>二级缓存需要手动开启和配置，他是基于namespace级别的缓存</p></li><li><p>为了提高扩展性，mybatis定义了缓存接口Cache。我们可以通过实现Cache接口来定义二级缓存</p></li></ul></li></ol><h2 id="13-3一级缓存"><a href="#13-3一级缓存" class="headerlink" title="13.3一级缓存"></a>13.3一级缓存</h2><ul><li>一级缓存也叫本地缓存：<ul><li>与数据库一次绘画期间查询到的数据会放在本地缓存中。</li><li>以后如果需要获取相同的数据，直接从缓存中拿，没必要再去查询数据库；</li></ul></li></ul><p>测试步骤：</p><ol><li>要开启日志</li><li>测试在一个Session中查询两次相同记录</li><li>查看查询</li></ol><p>缓存失效的情况：</p><ol><li>查询不同的东西</li><li>增删改操作，可能会改变原来的数据，所以必定会刷新缓存！</li><li>查询不同的Mapper</li><li>手动清除缓存sqlseesion.clear</li></ol><p>小结：一级缓存默认是开启的，只在一次sqlsession中有效，也就是拿到链接到关闭连接这个区间段！</p><p>一级缓存就是一个Mapper</p><h2 id="13-3二级缓存"><a href="#13-3二级缓存" class="headerlink" title="13.3二级缓存"></a>13.3二级缓存</h2><p>二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存</p><p>基于namespace级别的缓存，一个名称空间，对应一个二级缓存</p><ul><li>工作机制<ul><li>一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中；</li><li>如果当前会话关闭了，这个会话对应的一级缓存就没了，但是我们想要的是，会话关闭了，一级缓存中的数据被保存在二级缓存中；</li><li>新的会话查询信息，就可以从二级缓存中获取内容；</li><li>不同mapper查出的数据会放在自己对应的缓存中；</li></ul></li></ul><p>步骤：</p><ol><li><p>开启缓存</p><p><code>&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</code></p></li><li><p>在要使用二级缓存中的Mapper开启</p><cache></cache></li><li><p>测试</p><ol><li>问题：我们需要将实体类序列化！否则就会报错！</li></ol></li></ol><p>小结：</p><ul><li>只要开启了二级缓存，在同一个Mapper下就有效</li><li>所有的数据都会先放在一级缓存中；</li><li>只有当会话提交，或者关闭的时候，才会提交到二级缓存中</li></ul></mapper>]]></content>
      
      
      <categories>
          
          <category> CodeStudy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Mybatis </tag>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客文章</title>
      <link href="/2021/10/17/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
      <url>/2021/10/17/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>第一章</p><p>内容</p><p>第二章</p><p>内容</p><p>参考文献</p><p><a href="http://www.runchaun.cn/">www.runchaun.cn</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/10/17/hello-world/"/>
      <url>/2021/10/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
